/*
 * Copyright 2013 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors: Ben Skeggs
 */

#ifdef INCLUDE_PROC
process(PROC_PERF, #perf_init, #perf_recv)
#endif

/******************************************************************************
 * PERF data segment
 *****************************************************************************/
#ifdef INCLUDE_DATA
// parameters
perf_polling_period_us: .b32 100000
perf_slot1: .b8 0
perf_slot2: .b8 0
perf_slot3: .b8 0
#if NVKM_PPWR_CHIPSET >= GF100
perf_slot4: .b8 0
perf_slot5: .b8 0
perf_slot6: .b8 0
perf_slot7: .b8 0
#endif
.align 4
#endif

/******************************************************************************
 * PERF code segment
 *****************************************************************************/
#ifdef INCLUDE_CODE

// description
//
// $r15 - current (perf)
// $r14 - sender process name
// $r13 - message
// $r12 - data0
// $r11 - data1
// $r0  - zero
perf_recv:
	imm32($r10, PROC_HOST)
	cmp b32 $r14 $r10
	bra ne #perf_recv_not_host
		imm32($r10, PERF_MSG_GET_SLOTS)
		cmp b32 $r13 $r10
		bra e #perf_recv_get_slots
		imm32($r10, PERF_MSG_SET_SLOT)
		cmp b32 $r13 $r10
		bra e #perf_recv_set_slot
		bra   #perf_recv_host

perf_recv_get_slots:
	ld(b8, $r12, #perf_slot3)
	shl b32 $r12 8
	ld(b8, $r12, #perf_slot2)
	shl b32 $r12 8
	ld(b8, $r12, #perf_slot1)
	shl b32 $r12 8
	or $r12 0xff
#if NVKM_PPWR_CHIPSET >= GF100
	ld(b8, $r11, #perf_slot7)
	shl b32 $r11 8
	ld(b8, $r11, #perf_slot6)
	shl b32 $r11 8
	ld(b8, $r11, #perf_slot5)
	shl b32 $r11 8
	ld(b8, $r11, #perf_slot4)
#endif
	bra #perf_recv_host

perf_recv_set_slot:
	mulu $r12 16
	add b32 $r12 0x504
	iowr I[$r12] $r11
	bra #perf_recv_exit

perf_recv_not_host:
	call(perf_counter_readout)
	ld(b32, $r14, #perf_polling_period_us)
	call(ticks_from_us)
	call(timer)
	bra #perf_recv_exit

perf_recv_host:
	call(send)
perf_recv_exit:
	ret

// description
//
// $r15 - current (perf)
// $r0  - zero
perf_counter_readout:
	push $r1
	push $r2
	push $r3
	push $r4
#if NVKM_PPWR_CHIPSET >= GF100
	push $r5
	push $r6
	push $r7
	push $r8
#endif

	// read out all at once to reduce latency problems
	nv_iord($r1, NV_PPWR_COUNTER_COUNT(0))
	nv_iord($r2, NV_PPWR_COUNTER_COUNT(1))
	nv_iord($r3, NV_PPWR_COUNTER_COUNT(2))
	nv_iord($r4, NV_PPWR_COUNTER_COUNT(3))
#if NVKM_PPWR_CHIPSET >= GF100
	nv_iord($r5, NV_PPWR_COUNTER_COUNT(4))
	nv_iord($r6, NV_PPWR_COUNTER_COUNT(5))
	nv_iord($r7, NV_PPWR_COUNTER_COUNT(6))
	nv_iord($r8, NV_PPWR_COUNTER_COUNT(7))
#endif

	imm32($r14, NV_PPWR_COUNTER_COUNT_RESET)
	nv_iowr(NV_PPWR_COUNTER_COUNT(0), $r14)
	nv_iowr(NV_PPWR_COUNTER_COUNT(1), $r14)
	nv_iowr(NV_PPWR_COUNTER_COUNT(2), $r14)
	nv_iowr(NV_PPWR_COUNTER_COUNT(3), $r14)
#if NVKM_PPWR_CHIPSET >= GF100
	nv_iowr(NV_PPWR_COUNTER_COUNT(4), $r14)
	nv_iowr(NV_PPWR_COUNTER_COUNT(5), $r14)
	nv_iowr(NV_PPWR_COUNTER_COUNT(6), $r14)
	nv_iowr(NV_PPWR_COUNTER_COUNT(7), $r14)
#endif

	// with that we always get 8 bit values
	div $r1 $r1 0xff

	div $r2 $r2 $r1
	div $r3 $r3 $r1
	div $r4 $r4 $r1
#if NVKM_PPWR_CHIPSET >= GF100
	div $r5 $r5 $r1
	div $r6 $r6 $r1
	div $r7 $r7 $r1
	div $r8 $r8 $r1
#endif

	st(b8, #perf_slot1, $r2)
	st(b8, #perf_slot2, $r3)
	st(b8, #perf_slot3, $r4)
#if NVKM_PPWR_CHIPSET >= GF100
	st(b8, #perf_slot4, $r5)
	st(b8, #perf_slot5, $r6)
	st(b8, #perf_slot6, $r7)
	st(b8, #perf_slot7, $r8)
#endif

#if NVKM_PPWR_CHIPSET >= GF100
	pop $r8
	pop $r7
	pop $r6
	pop $r5
#endif
	pop $r4
	pop $r3
	pop $r2
	pop $r1

	ret

// description
//
// $r15 - current (perf)
// $r0  - zero
perf_init:
	imm32($r14, NV_PPWR_COUNTER_MODE_ALWAYS)
	nv_iowr(NV_PPWR_COUNTER_MODE(0), $r14)

	imm32($r14, NV_PPWR_COUNTER_MODE_IF_ANY)
	nv_iowr(NV_PPWR_COUNTER_MODE(1), $r14)
	nv_iowr(NV_PPWR_COUNTER_MODE(2), $r14)
	nv_iowr(NV_PPWR_COUNTER_MODE(3), $r14)
#if NVKM_PPWR_CHIPSET >= GF100
	nv_iowr(NV_PPWR_COUNTER_MODE(4), $r14)
	nv_iowr(NV_PPWR_COUNTER_MODE(5), $r14)
	nv_iowr(NV_PPWR_COUNTER_MODE(6), $r14)
	nv_iowr(NV_PPWR_COUNTER_MODE(7), $r14)
#endif

	// initial readout
	call(perf_counter_readout)

	// schedule the next read out
	ld(b32, $r14, #perf_polling_period_us)
	call #ticks_from_us
	call(timer)

	ret
#endif
